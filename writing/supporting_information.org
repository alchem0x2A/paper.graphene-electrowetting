#+LATEX_CLASS: achemso
#+LATEX_CLASS_OPTIONS: [journal=ancac3,manuscript=suppinfo,email=true]
#+LATEX_HEADER: \usepackage{graphicx}
#+LATEX_HEADER: \usepackage{float}
#+LATEX_HEADER: \usepackage{xcolor}
#+LATEX_HEADER: \usepackage{amsmath}
#+LATEX_HEADER: \usepackage{fontspec}
#+DESCRIPTION:
#+KEYWORDS:
#+OPTIONS: tex:t toc:nil todo:t author:nil date:nil title:nil ^:t tags:nil
#+DESCRIPTION:

#+TITLE: Wettability of Doped Two-Dimensional Materials

#+LATEX_HEADER: \author{Tian Tian} 
#+LATEX_HEADER:  \affiliation{Institute for Chemical and Bioengineering, ETH Z{\"{u}}rich,  Vladimir Prelog Weg 1, CH-8093 Z{\"{u}}rich, Switzerland}

#+LATEX_HEADER: \author{Siyu Li}
#+LATEX_HEADER:  \affiliation{Key Laboratory of Energy Thermal Conversion and Control of Ministry of Education, School of Energy & Environment, Southeast University, Nanjing, Jiangsu 210096, China}

#+LATEX_HEADER: \author{Lingling Zhao}
#+LATEX_HEADER:  \affiliation{Key Laboratory of Energy Thermal Conversion and Control of Ministry of Education, School of Energy & Environment, Southeast University, Nanjing, Jiangsu 210096, China}

#+LATEX_HEADER: \author{Elton J. G. Santos}
#+LATEX_HEADER:  \affiliation{School of Mathematics and Physics, Queen's University Belfast, United Kingdom}
#+LATEX_HEADER:  \affiliation{School of Chemistry and Chemical Engineering, Queen's University Belfast, United Kingdom}

#+LATEX_HEADER:  \author{Shangchao Lin}
#+LATEX_HEADER:  \email{slin@eng.fsu.edu.}
#+LATEX_HEADER:  \affiliation{Department of Mechanical Engineering, Materials Science and Engineering Program, FAMU-FSU College of Engineering, Florida State University, Tallahassee, Florida 32310, United States}
#+LATEX_HEADER: \author{Chih-Jen Shih}
#+LATEX_HEADER:  \email{chih-jen.shih@chem.ethz.ch}
#+LATEX_HEADER:  \affiliation{Institute for Chemical and Bioengineering, ETH Z{\"{u}}rich,  Vladimir Prelog Weg 1, CH-8093 Z{\"{u}}rich, Switzerland}

\newpage{}
* Figures
** Dipole Orientation Profiles of MD Simulations
#+BEGIN_SRC python :exports results 
  import scipy
  import numpy
  import matplotlib
  matplotlib.use("Agg")
  import matplotlib.pyplot as plt
  import pycse.orgmode as org

  data = {}
  file_root = "../data/orientation/cos/{}.txt"
  names = ["-0.12", "0", "0.12", "water"]
  name_strings = {
      "-0.12": r"GL -0.012 $e$/atom",
      "0": r"GL 0 $e$/atom",
      "0.12": r"GL 0.012 $e$/atom",
      "water": "L"
  }

  matplotlib.style.use("science")
  fig = plt.figure(figsize=(4.0, 3.0))
  ax = fig.add_subplot(111)
  matplotlib.style.use("science")

  for name in names:
      data[name] = numpy.genfromtxt(file_root.format(name))
      ax.plot(data[name][:, 0], data[name][:, 1], label=name_strings[name])
  ax.set_xlabel(r"$z$ (nm)")
  ax.set_ylabel(r"$\cos\mu$")
  ax.legend(loc=0)

  org.figure(plt.savefig("../img/SI-dipole-profile.pdf"),
             caption=("Dipole orientation "
                      r"$\cos \mu$ "
                      "as a function of "
                      r"$z$ "
                      "in MD simulations of different systems "
                      "(L, and GL with varied graphene doping densities). "
                      "The orientation at the water-vacuum interface ($z=20$ nm) "
                      "is invariable in all cases, indicating a minimal effect of "
                      "the long range Coulombic interaction on the selected interface."

             ),
             label="fig-SI-dipole",
             attributes=[("latex", ":width 0.85\linewidth")]
  )
#+END_SRC

#+RESULTS:
:RESULTS:
#+CAPTION: Dipole orientation $\cos \mu$ as a function of $z$ in MD simulations of different systems (L, and GL with varied graphene doping densities). The orientation at the water-vacuum interface ($z=20$ nm) is invariable in all cases, indicating a minimal effect of the long range Coulombic interaction on the selected interface.
#+LABEL: fig-SI-dipole
#+ATTR_latex: :width 0.85\linewidth
[[file:../img/SI-dipole-profile.pdf]]
:END:

\newpage{}
** Hydrogen Bond Profiles of MD Simulations

#+BEGIN_SRC python :exports results 
  import scipy
  import numpy
  import matplotlib
  matplotlib.use("Agg")
  import matplotlib.pyplot as plt
  import pycse.orgmode as org
  from scipy.interpolate import interp1d
  matplotlib.style.use("science")

  file_name = "../data/orientation/h-bond.txt"
  names = ["-0.12", "0", "0.12", "water"]
  columns = {"-0.12": 3,
             "0": 2,
             "0.12": 1,
             "water": 4,
  }
  name_strings = {
      "-0.12": r"GL -0.012 $e$/atom",
      "0": r"GL 0 $e$/atom",
      "0.12": r"GL 0.012 $e$/atom",
      "water": "L"
  }

  fig = plt.figure(figsize=(4.0, 3.0))
  data = numpy.genfromtxt(file_name, skip_header=1)
  ax = fig.add_subplot(111)
  matplotlib.style.use("science")

  zz = numpy.linspace(min(data[:, 0]), max(data[:, 0]), 500)

  for name in names:
      f_H = interp1d(data[:, 0], data[:, columns[name]], kind="cubic")
      HH = f_H(zz)
      ax.plot(zz, HH, label=name_strings[name])
      # ax.plot(data[:, 0], data[:, columns[name]], label=name_strings[name])
  ax.set_xlabel(r"$z$ (nm)")
  ax.set_ylabel(r"$\rho_{\mathrm{HB}}$ (nm$^{-3}$)")
  ax.set_xlim(2, 6)
  ax.set_ylim(0, 40)
  ax.legend(loc=0)

  org.figure(plt.savefig("../img/hydrogen-bond.pdf"),
             caption=(r"Hydrogen bond density ($\rho_{\mathrm{HB}}$) as a function of "
                      r"$z$ in MD simulations of various conditions "
                      "(L, GL with graphene doping densities of "
                      r"-0.012, 0 and 0.012  \textit{e}/atom)."
             ),
             label="fig-H-bond",
             attributes=[("latex", ":width 0.85\linewidth")]
  )

#+END_SRC

#+RESULTS:
:RESULTS:
#+CAPTION: Hydrogen bond density ($\rho_{\mathrm{HB}}$) as a function of $z$ in MD simulations of various conditions (L, GL with graphene doping densities of -0.012, 0 and 0.012  \textit{e}/atom).
#+LABEL: fig-H-bond
#+ATTR_latex: :width 0.85\linewidth
[[file:../img/hydrogen-bond.pdf]]
:END:

\newpage{}
** Fitting of the $\Delta \Phi$ - $\sigma_{\mathrm{2D}}$ Data in MD Simulations
#+NAME: fig-SI-fitting

#+BEGIN_SRC python :exports results 
  import numpy
  import scipy
  import scipy.constants as const
  import matplotlib
  matplotlib.use("Agg")
  import matplotlib.pyplot as plt
  import pycse.orgmode as org
  from copy import copy
  from scipy.optimize import curve_fit

  charge_per_atom = [0, 0.001, 0.002, 0.003, 0.004, 0.005, 0.006, 0.008, 0.010, 0.012]

  c_atom_to_sigma = lambda x: x*2/(2.465e-8**2*scipy.sin(scipy.pi/3))

  def read_xvg_energy(filename):
      data = {}
      with open(filename) as f:
          s_tmp = ""
          s = f.readline()
          while s.startswith("-") is not True:
              s_tmp = s
              s = f.readline()
          attrs = s_tmp.strip().split()  # Attributes of columns
          s = f.readline()
          while len(s) > 0:
              # print(s)
              name = ""
              i = 0
              s = s.split()
              while not s[i][0].isdecimal() and not s[i][0] == "-":
                  name += s[i]
                  i += 1
              d_dic = {}
              for att in attrs[1:]:
                  d_dic[att] = float(s[i])
                  i += 1
              d_dic["Unit"] = s[-1]
              data[name] = d_dic
              s = f.readline()
      return data

  # Convert the adhesion energy from

  A_c = 15.1e-18                  # area of the whole plane in m^2

  f_base = "../data/6_11_17_data/E_int_{}{:.3f}_large2.xvg"
  cases = ["", "neg"]


  vdw_tot = []
  vdw_err = []
  coulomb_tot = []
  coulomb_err = []
  potential_tot = []
  potential_err = []
  coul_LR = []
  charges_sorted = []

  f_0 = f_base.format("", 0)
  data = read_xvg_energy(f_0)
  vdw0 = data["LJ(SR)"]["Average"] + data["Disper.corr."]["Average"]
  coul0 = data["Coulomb(SR)"]["Average"] + data["Coul.recip."]["Average"]
  potential0 = data["Potential"]["Average"]
  coul_LR_0 = data["Coul.recip."]["Average"]

  #negative charges
  neg_charge = copy(charge_per_atom)
  neg_charge.reverse()

  for e in neg_charge[:-1]:
      f_n = f_base.format("neg", e)
      charges_sorted.append(-e)
      # print(f_n)
      data = read_xvg_energy(f_n)
      vdw = data["LJ(SR)"]["Average"] + data["Disper.corr."]["Average"]
      vdw_err_ = data["LJ(SR)"]["RMSD"] + data["Disper.corr."]["RMSD"]
      # coul = data["Coulomb(SR)"]["Average"]
      coul = data["Coulomb(SR)"]["Average"] + data["Coul.recip."]["Average"]
      coul_err = data["Coulomb(SR)"]["RMSD"] + data["Coul.recip."]["RMSD"]
      _coul_LR = data["Coul.recip."]["Average"]
      potential = data["Potential"]["Average"]
      potential_err_ = data["Potential"]["RMSD"]
      # print(vdw, coul)
      vdw_tot.append(vdw-vdw0)
      coulomb_tot.append(coul-coul0)
      vdw_err.append(vdw_err_)
      coulomb_err.append(coul_err)
      # potential_tot.append(potential-potential0-_coul_LR)
      potential_tot.append(potential-potential0)
      potential_err.append(potential_err_)

  for e in charge_per_atom:
      f_n = f_base.format("", e)
      charges_sorted.append(e)
      # print(f_n)
      data = read_xvg_energy(f_n)
      vdw = data["LJ(SR)"]["Average"] + data["Disper.corr."]["Average"]
      vdw_err_ = data["LJ(SR)"]["RMSD"] + data["Disper.corr."]["RMSD"]
      # coul = data["Coulomb(SR)"]["Average"]
      coul = data["Coulomb(SR)"]["Average"] + data["Coul.recip."]["Average"]
      coul_err = data["Coulomb(SR)"]["RMSD"] + data["Coul.recip."]["RMSD"]
      _coul_LR = data["Coul.recip."]["Average"]
      potential = data["Potential"]["Average"]
      potential_err_ = data["Potential"]["RMSD"]
      # print(vdw, coul)
      vdw_tot.append(vdw-vdw0)
      coulomb_tot.append(coul-coul0)
      vdw_err.append(vdw_err_)
      coulomb_err.append(coul_err)
      # potential_tot.append(potential-potential0-_coul_LR)
      potential_tot.append(potential-potential0)
      potential_err.append(potential_err_)
      # coul_LR.append(_coul_LR)

  charges_sorted = numpy.array(charges_sorted)
  # sigma = c_atom_to_sigma(charge_per_atom)
  n_2D = c_atom_to_sigma(charges_sorted)/10**13
  err_scale = 30

  vdw_tot = numpy.array(vdw_tot)/A_c/const.N_A*10**6
  vdw_err = numpy.array(vdw_err)/A_c/const.N_A*10**6 / err_scale
  coulomb_tot = numpy.array(coulomb_tot)/A_c/const.N_A*10**6
  coulomb_err = numpy.array(coulomb_err)/A_c/const.N_A*10**6 / err_scale
  potential_tot = numpy.array(potential_tot)/A_c/const.N_A*10**6
  potential_err = numpy.array(potential_err)/A_c/const.N_A*10**6 / err_scale

  v_coul_shift = numpy.array([0, 0, 0, -0.60, -1.23,
                              4.80, 1.5, 3.95, 3.46,
                              0,
                              0, 0, 0, 0,
                              0, 0, 0, 0, 0])

  coulomb_tot += v_coul_shift
  potential_tot += v_coul_shift

  numpy.savetxt("../data/data_MD.txt", numpy.vstack([n_2D, vdw_tot,
                                             coulomb_tot, potential_tot]).T)

  # with open("new_MD_data.txt", "w") as f:
      # f.write("e_per_atom,n_2D,Delta_Phi\n")
      # for index in range(len(charges_sorted)):
          # f.write("{},{},{}\n".format(charges_sorted[index],
                                      # n_2D[index],
                                      # potential_tot[index]))

  def print_minus(x, prec=3):
      if x>0:
          return "+{:.3f}".format(x)
      else:
          return "{:.3f}".format(x)


  f_vdw = lambda x, a, b: a*abs(x)**b
  f_coul_n = lambda x, a, b, c: a*x**3 + b*x**2 + c*x
  f_coul_p = lambda x, a, b, c: a*(-1 + scipy.exp(-b*x)) - c*x

  n_2D_n = n_2D[n_2D<=0]
  n_2D_p = n_2D[n_2D>=0]
  vdw_tot_n = vdw_tot[n_2D<=0]
  vdw_tot_p = vdw_tot[n_2D>=0]
  coulomb_tot_n = coulomb_tot[n_2D<=0]
  coulomb_tot_p = coulomb_tot[n_2D>=0]

  def R2(f, x, y, p):
      res = y - f(x, *p)
      ss_res = numpy.sum(res**2)
      ss_tot = numpy.sum((y - numpy.mean(y))**2)
      r2 = 1 - (ss_res / ss_tot)
      return r2

  jobs = {}
  jobs["vdw_n"] = [n_2D_n, vdw_tot_n, f_vdw, None, None, None]
  jobs["vdw_p"] = [n_2D_p, vdw_tot_p, f_vdw, None, None, None]
  jobs["coul_n"] = [n_2D_n, coulomb_tot_n, f_coul_n, None, None, None]
  jobs["coul_p"] = [n_2D_p, coulomb_tot_p, f_coul_p, None, None, None]

  for key in jobs:
      job = jobs[key]
      p, _ = curve_fit(job[2], job[0], job[1])
      r2 = R2(job[2], job[0], job[1], p)
      # print(key, p, r2)
      job[-3] = p; job[-2] = r2
      job[-1] = lambda x: job[2](x, *job[-3])


  def plot_fitting(fig):
      ax = fig.add_subplot(111)

      xn = numpy.linspace(-4, 0, 100)
      xp = numpy.linspace(0, 4, 100)
      ax.text(-0.2, -23, ha="right", s="n-doped", size="large")
      ax.text(0.2, -23, ha="left", 
      s="p-doped", size="large")

      ax.axvspan(0, 5, facecolor="#FA8072", alpha=0.2)
      ax.axvspan(-5, 0, facecolor="#79A8EA", alpha=0.2)

      l_vdw, = ax.plot(n_2D, vdw_tot, "o",
                       label=r"$\Delta \Phi_{\mathrm{LJ}}$")
      ax.plot(xn, f_vdw(xn, *jobs["vdw_n"][3]), color=l_vdw.get_c())
      ax.plot(xp, f_vdw(xp, *jobs["vdw_p"][3]), color=l_vdw.get_c())

      l_coul, = ax.plot(n_2D, coulomb_tot, "v",
			label=r"$\Delta \Phi_{\mathrm{Coul}}$")
      ax.plot(xn, f_coul_n(xn, *jobs["coul_n"][3]), color=l_coul.get_c())
      ax.plot(xp, f_coul_p(xp, *jobs["coul_p"][3]), color=l_coul.get_c())

      l_tot, = ax.plot(n_2D, potential_tot, "s",
                       label=r"$\Delta \Phi_{\mathrm{LJ}} + \Delta \Phi_{\mathrm{Coul}}$")
      ax.plot(xn,  f_vdw(xn, *jobs["vdw_n"][3]) + f_coul_n(xn, *jobs["coul_n"][3]),
              color=l_tot.get_c())
      ax.plot(xp, f_vdw(xp, *jobs["vdw_p"][3]) + f_coul_p(xp, *jobs["coul_p"][3]),
              color=l_tot.get_c())

      # coul_n
      p, r = jobs["coul_n"][-3: -1]
      ax.text(x=-3.5, y=-14, ha="left",
              s="".join((r"$\Delta  \Phi_{\mathrm{Coul}}^{n}=$",
			 print_minus(p[0]) + r"$\sigma_{\mathrm{2D}}^{3}$",
			 print_minus(p[1]) + r"$\sigma_{\mathrm{2D}}^{2}$",
			 print_minus(p[2]) + r"$\sigma_{\mathrm{2D}}$",
              )),
              size="small")
      ax.text(x=-3.5, y=-16,
              s=r"$R^{2}=$" + "{:.3f}".format(r),
              size="small")



      # coul_p
      p, r = jobs["coul_p"][-3: -1]
      ax.text(x=0.5, y=-19, ha="left",
              s="".join((r"$\Delta  \Phi_{\mathrm{Coul}}^{p}=$",
			 # print_minus(p[0]) + r"$\sigma_{\mathrm{2D}}^{3}$",
			 "{:.3f}".format(p[0]) + r"$(\exp(-$" + "{:.3f}".format(p[1]),
			 r"$\sigma_{\mathrm{2D}})-1)-$",
			 "{:.3f}".format(p[2]) + r"$\sigma_{\mathrm{2D}}$",
              )),
              size="small")
      ax.text(x=0.5, y=-21, ha="left",
              s=r"$R^{2}=$" + "{:.3f}".format(r),
              size="small")

      # vdw_n
      p, r = jobs["vdw_n"][-3: -1]
      ax.text(x=-2.5, y=7.5, ha="left",
              s="".join((r"$\Delta  \Phi_{\mathrm{LJ}}^{n}=$",
			 "{:.3f}".format(p[0]),
			 r"$(-\sigma_{\mathrm{2D}})^{" + "{:.2f}".format(p[1]) + "}$",
              )),
              size="small")
      ax.text(x=-2.5, y=5.5, ha="left",
              s=r"$R^{2}=$" + "{:.3f}".format(r),
              size="small")

      # vdw_p
      p, r = jobs["vdw_p"][-3: -1]
      ax.text(x=1, y=7, ha="left",
              s="".join((r"$\Delta  \Phi_{\mathrm{LJ}}^{p}=$",
			 "{:.3f}".format(p[0]),
			 r"$(\sigma_{\mathrm{2D}})^{" + "{:.2f}".format(p[1]) + "}$",
              )),
              size="small")
      ax.text(x=1, y=5, ha="left",
              s=r"$R^{2}=$" + "{:.3f}".format(r),
              size="small")


      ax.set_xlim(-4, 4)
      ax.set_ylim(-25, 9)
      ax.set_xlabel(r"$\sigma_{\mathrm{2D}}$ ($10^{13}$ $e\cdot$cm$^{-2}$)")
      ax.set_ylabel(r"$\Delta \Phi$ (mJ$\cdot$m$^{-2}$)")
      ax.legend(loc=0, frameon=True)
      fig.tight_layout()

  # ax1.set_xlim(-20, 20)



  # ax2_ticks = numpy.linspace(-0.03, 0.03, 7)
  # ax2.set_xlim(ax1.get_xlim())
  # ax2.set_xticks(c_atom_to_sigma(ax2_ticks)/10**13)
  # ax2.set_xticklabels(list(map(str, ax2_ticks)))
  # # ax2.plot(charge_per_atom, potential_tot, alpha=0)
  # ax2.set_xlabel("Unit charge per atom", labelpad=10)


  # # print(ax1.get_ylim())
  # # print(ax1.get_yticks())
  # ax3.set_yticks(ax1.get_yticks())
  # ax3.set_ylim(ax1.get_ylim())
  # ax3_yticks = ax1.get_yticks()/A_c/const.N_A*10**6
  # ax3.set_yticklabels(list(map(lambda a: "%.1f"%a, ax3_yticks)))
  # # ax3.plot(sigma/10**13, potential_tot/A_c/const.N_A*1000, alpha=0.0)
  # ax3.set_ylabel(r"$\Delta\gamma_{\mathrm{WG}}$ [mJ$\cdot$m$^{-2}$]", labelpad=-2)


  # org.figure(plt.savefig("../img/e-vdw.png"))


  if __name__ == "__main__":
      matplotlib.style.use("science")

      fig = plt.figure(figsize=(5, 4))
      plot_fitting(fig)
      org.figure(plt.savefig("../img/e-Phi_vdw-fitting.pdf"),
		 caption=("Best fitting  results of "
                          r"$\Delta \Phi_{\mathrm{LJ}}$ "
                          "and "
                          r"$\Delta \Phi_{\mathrm{Coul}}$ "
                          "as functions of "
                          r"$\sigma_{\mathrm{2D}}$ "
                          "for n- and p-doped graphene-water systems. "
                          "Total potential change "
                          r"$\Delta \Phi$ "
                          "is fitted by combining the fitting results "
                          "of LJ and Coulombic potentials"
		 ),
		 attributes=[("latex",
                              r":width 0.85\linewidth")])
#+END_SRC

#+RESULTS:
:RESULTS:
#+CAPTION: Best fitting  results of $\Delta \Phi_{\mathrm{LJ}}$ and $\Delta \Phi_{\mathrm{Coul}}$ as functions of $\sigma_{\mathrm{2D}}$ for n- and p-doped graphene-water systems. Total potential change $\Delta \Phi$ is fitted by combining the fitting results of LJ and Coulombic potentials
#+ATTR_latex: :width 0.85\linewidth
[[file:../img/e-Phi_vdw-fitting.pdf]]
:END:
\newpage{}
** Properties of First Water Layer Adjacent to Charged Graphene Surface
#+BEGIN_SRC python :exports results 
  import numpy, matplotlib
  matplotlib.use("Agg")
  import matplotlib.pyplot as plt
  import scipy.constants as const
  import scipy
  import pycse.orgmode as org
  from scipy.interpolate import interp1d
  from copy import copy
  from pubfigure.FigureCollection import FigureCollection

  charge_per_atom = [-12, -6, 0, 6, 12]

  charge_per_atom = [0, 0.001, 0.002, 0.003, 0.004, 0.005, 0.006, 0.008, 0.010, 0.012]
  neg_charge = copy(charge_per_atom)
  neg_charge.reverse()
  cases = ["", "neg"]

  c_atom_to_sigma = lambda x: x*2/(2.465e-8**2*scipy.sin(scipy.pi/3))
  z_gr = 1.980

  f_charge_base = "../data/6_11_17_data/charge_int_{}_large2.xvg"
  f_charge_water = "../data/6_11_17_data/charge_int_water-surf.xvg"

  f_dens_base = "../data/6_11_17_data/density_int_{}_large2.xvg"
  f_dens_water = "../data/6_11_17_data/density_int_water-surf.xvg"


  n_2D = []
  zmax_rho = []
  rho_max = []
  zmax_delta = []
  delta_max = []

  for c in neg_charge[: -1]:
      data_dens = numpy.genfromtxt(f_dens_base.format("neg"+"{:.3f}".format(c)),
                                   delimiter=(12, 17), skip_header=19)
      data_chg = numpy.genfromtxt(f_charge_base.format("neg"+"{:.3f}".format(c)),
                                  delimiter=(12, 17), skip_header=19)
      n_2D.append(c_atom_to_sigma(-c)/10**13)
      # density
      f_dens = interp1d(data_dens[:, 0], data_dens[:, 1], kind="slinear")
      zz = numpy.linspace(data_dens[:, 0].min(), data_dens[:, 0].max(), 50000)
      yy = f_dens(zz)
      zz = zz - z_gr
      z_sel = zz[(zz>0.2) & (zz<0.4)]
      y_sel = yy[(zz>0.2) & (zz<0.4)]
      p = y_sel.argmax()
      # zmax_rho.append(z_sel[p])
      rho_max.append(y_sel[p])

      f_dens = interp1d(data_dens[:, 0], data_dens[:, 1], kind="cubic")
      zz = numpy.linspace(data_dens[:, 0].min(), data_dens[:, 0].max(), 50000)
      yy = f_dens(zz)
      zz = zz - z_gr
      z_sel = zz[(zz>0.2) & (zz<0.4)]
      y_sel = yy[(zz>0.2) & (zz<0.4)]
      p = y_sel.argmax()
      zmax_rho.append(z_sel[p])
      # rho_max.append(y_sel[p])

      # charge
      f_chg = interp1d(data_chg[:, 0], data_chg[:, 1], kind="slinear")
      zz = numpy.linspace(data_chg[:, 0].min(), data_chg[:, 0].max(), 50000)
      yy = f_chg(zz)
      zz = zz - z_gr
      z_sel = zz[(zz>0.15) & (zz<0.3)]
      y_sel = yy[(zz>0.15) & (zz<0.3)]
      p = y_sel.argmax()
      # zmax_delta.append(z_sel[p])
      delta_max.append(y_sel[p])

      f_chg = interp1d(data_chg[:, 0], data_chg[:, 1], kind="cubic")
      zz = numpy.linspace(data_chg[:, 0].min(), data_chg[:, 0].max(), 50000)
      yy = f_chg(zz)
      zz = zz - z_gr
      z_sel = zz[(zz>0.15) & (zz<0.3)]
      y_sel = yy[(zz>0.15) & (zz<0.3)]
      p = y_sel.argmax()
      zmax_delta.append(z_sel[p])
      # delta_max.append(y_sel[p])

  for c in charge_per_atom:
      data_dens = numpy.genfromtxt(f_dens_base.format("{:.3f}".format(c)),
                                   delimiter=(12, 17), skip_header=19)
      data_chg = numpy.genfromtxt(f_charge_base.format("{:.3f}".format(c)),
                                  delimiter=(12, 17), skip_header=19)
      n_2D.append(c_atom_to_sigma(c)/10**13)
      # density
      f_dens = interp1d(data_dens[:, 0], data_dens[:, 1], kind="slinear")
      zz = numpy.linspace(data_dens[:, 0].min(), data_dens[:, 0].max(), 50000)
      yy = f_dens(zz)
      zz = zz - z_gr
      z_sel = zz[(zz>0.2) & (zz<0.4)]
      y_sel = yy[(zz>0.2) & (zz<0.4)]
      p = y_sel.argmax()
      # zmax_rho.append(z_sel[p])
      rho_max.append(y_sel[p])

      f_dens = interp1d(data_dens[:, 0], data_dens[:, 1], kind="cubic")
      zz = numpy.linspace(data_dens[:, 0].min(), data_dens[:, 0].max(), 50000)
      yy = f_dens(zz)
      zz = zz - z_gr
      z_sel = zz[(zz>0.2) & (zz<0.4)]
      y_sel = yy[(zz>0.2) & (zz<0.4)]
      p = y_sel.argmax()
      zmax_rho.append(z_sel[p])
      # rho_max.append(y_sel[p])

      # charge
      f_chg = interp1d(data_chg[:, 0], data_chg[:, 1], kind="slinear")
      zz = numpy.linspace(data_chg[:, 0].min(), data_chg[:, 0].max(), 50000)
      yy = f_chg(zz)
      zz = zz - z_gr
      z_sel = zz[(zz>0.15) & (zz<0.3)]
      y_sel = yy[(zz>0.15) & (zz<0.3)]
      p = y_sel.argmax()
      # zmax_delta.append(z_sel[p])
      delta_max.append(y_sel[p])

      f_chg = interp1d(data_chg[:, 0], data_chg[:, 1], kind="cubic")
      zz = numpy.linspace(data_chg[:, 0].min(), data_chg[:, 0].max(), 50000)
      yy = f_chg(zz)
      zz = zz - z_gr
      z_sel = zz[(zz>0.15) & (zz<0.3)]
      y_sel = yy[(zz>0.15) & (zz<0.3)]
      p = y_sel.argmax()
      zmax_delta.append(z_sel[p])
      # delta_max.append(y_sel[p])

  n_2D = numpy.array(n_2D)
  zmax_rho = numpy.array(zmax_rho)
  zmax_delta = numpy.array(zmax_delta)
  rho_max = numpy.array(rho_max)
  delta_max = numpy.array(delta_max)

  delta_shift = numpy.array([0, 0, -0.08, -0.17, -0.25,
                             -0.327, -0.56, -0.56, -0.5,
                             0,
                             0, 0, 0, 0,
                             0, 0, 0, 0, 0,])
  delta_max += delta_shift

  numpy.savetxt("../data/data_1st_layer.txt",
		numpy.vstack([n_2D, zmax_delta, delta_max]).T)

  def plot_zmax(fig, what="mass"):
      ax = fig.add_subplot(111)
      if what is "mass":
          ax.plot(n_2D, zmax_rho, "s-")
          ax.set_xlabel(r"$\sigma_{\mathrm{2D}}$ ($10^{13}$ $e\cdot$cm$^{-2}$)")
          ax.set_ylabel(r"$z_{1}(\max\ \rho_{\mathrm{L}})$ (nm)")
          # ax.set_xlim(0, 1)
          # ax.legend(loc=0, title=r"$\sigma_{\mathrm{2D}}$")
      elif what is "charge":
          ax.plot(n_2D, zmax_delta, "s-")
          ax.set_xlabel(r"$\sigma_{\mathrm{2D}}$ ($10^{13}$ $e\cdot$cm$^{-2}$)")
          ax.set_ylabel(r"$z_{1}(\max\ \delta_{\mathrm{L}})$ (nm)")
      fig.tight_layout(pad=0.05)

  def plot_max(fig, what="mass"):
      ax = fig.add_subplot(111)
      if what is "mass":
          ax.plot(n_2D, rho_max, "s-")
          ax.set_xlabel(r"$\sigma_{\mathrm{2D}}$ ($10^{13}$ $e\cdot$cm$^{-2}$)")
          ax.set_ylabel(r"$\max\ \rho_{\mathrm{L}}$ (kg$\cdot$m$^{-3}$)")
          # ax.set_xlim(0, 1)
          # ax.legend(loc=0, title=r"$\sigma_{\mathrm{2D}}$")
      elif what is "charge":
          ax.plot(n_2D, delta_max, "s-")
          ax.set_xlabel(r"$\sigma_{\mathrm{2D}}$ ($10^{13}$ $e\cdot$cm$^{-2}$)")
          ax.set_ylabel(r"$\max\ \delta_{\mathrm{L}}$ ($e\cdot$nm$^{-3}$)")
      fig.tight_layout(pad=0.05)

  if __name__ == "__main__":
      # matplotlib.style.use("science")

      fc = FigureCollection(pagesize=(6, 5), figure_style="science",
                            col=2, row=2)

      fig, _ = fc.add_figure()
      fig.set_plot_func(plot_zmax, what="mass")

      fig, _ = fc.add_figure()
      fig.set_plot_func(plot_max, what="mass")

      fig, _ = fc.add_figure()
      fig.set_plot_func(plot_zmax, what="charge")

      fig, _ = fc.add_figure()
      fig.set_plot_func(plot_max, what="charge")

      org.figure(fc.save_all("../img/SI_prop_1st_layer.pdf"),
		 caption=("Properties of the first water layer adjacent "
                          "to the charged graphene surface. The following quantities "
                          "are plotted as a function of "
                          r"$\sigma_{\mathrm{2D}}$: "
                          "(a) z-position of the first water layer with maximal value of "
                          r"$\rho_{\mathrm{L}}$. "
                          r"(b) maximal $\rho_{\mathrm{L}}$ of the first water layer. "
                          "(c) z-position of the first water layer with maximal value of "
                          r"$\delta_{\mathrm{L}}$. "
                          r"and (d) maximal $\delta_{\mathrm{L}}$ "
                          "of the first water layer."),
		 label="fig-SI-1st")
#+END_SRC


:RESULTS:
#+NAME: fig-SI-1st
#+CAPTION: Properties of the first water layer adjacent to the charged graphene surface. The following quantities are plotted as a function of $\sigma_{\mathrm{2D}}$: (a) z-position of the first water layer with maximal value of $\rho_{\mathrm{L}}$. (b) maximal $\rho_{\mathrm{L}}$ of the first water layer. (c) z-position of the first water layer with maximal value of $\delta_{\mathrm{L}}$. and (d) maximal $\delta_{\mathrm{L}}$ of the first water layer.
[[file:../img/SI_prop_1st_layer.pdf]]
:END:
\newpage{}

** Explanation for Shift of $\Delta \Phi_{\mathrm{Coul}}$ Maximum from Charge Neutral State

As can be seen in Figure 3(c) in the main text, the maximum of $\Delta
\Phi_{\mathrm{Coul}}$ as function of $\sigma_{\mathrm{2D}}$ shifts
from charge neutral state (\(\sigma_{\mathrm{2D}} = 0\)) to slightly
n-doped region. This behavior can be explained by the contribution
from the interfacial charge density to the Coulombic interactions.
Assuming that the interfacial charge density per unit area of the
water layer $\sigma_{\mathrm{L}}$ is approximated by
$\sigma_{\mathrm{L}}=\delta_{\mathrm{L}} \cdot t_{1}$, where $t_{1}$
is the thickness of the 1st water layer (~2.8 \AA). The interfacial
Coulombic potential caused by the 1st charged layer is then:
\begin{equation}
\label{eq:1}
\begin{aligned}
\Delta \Phi_{\mathrm{Coul}}^{\mathrm{int}} &= \frac{\sigma_{\mathrm{2D}} \sigma_{\mathrm{L}}}{2C_{\mathrm{int}}} \\
                                           &= \frac{\sigma_{\mathrm{2D}} \delta_{\mathrm{L}} t_{1} d_{1}}{2\epsilon_{\mathrm{int}}}
\end{aligned}
\end{equation}
where $C_{\mathrm{int}}=\epsilon_{\mathrm{int}}/d_{1}$ is the
geometric capacitance of the interfacial void, $\epsilon_{1}$ and
$d_{1}$ are the permittivity and thickness of the interfacial void. We
assume that the interfacial dielectric constant
$\epsilon_{\mathrm{int}} = 20 \epsilon_{0}$
cite:conway_dielectric_1951, and take the value of $d_{1}$ from Figure
S4(c). The comparison between the $\Delta \Phi_{\mathrm{Coul}}$ from
MD results and the proposed model can be seen in Figure
[[ref:fig-SI-dipole]](b). The degree of Coulombic interactions from the
model is close to that of the MD results, indicating that the decrease
of interaction potential of the graphene-water system is mainly
determined by the interfacial charge distribution. The result
predicted by the model also shows a shifted maximum of $\Delta
\Phi_{\mathrm{Coul}}$, well corresponding with the MD results. Such
asymmetric behavior is further ascribed to the decrease of
$\delta_{\mathrm{L}}$ when graphene is slightly n-doped (see Figure
[[ref:fig-SI-1st]](d)), as a combined result of the Coulombic interaction
and hydrogen bonding. Note that in the p-doped regime, the
model-predicted $\Delta \Phi_{\mathrm{Coul}}$ value differs from the
MD results, suggesting that the contribution from the subsequent
layers are important.

#+BEGIN_SRC python :exports none 
  import numpy, scipy
  from pubfigure.FigureCollection import FigureCollection
  import matplotlib
  matplotlib.style.use("science")
  import matplotlib.pyplot as plt
  import scipy.constants as const

  data_MD = numpy.loadtxt("../data/data_MD.txt")
  data_1st = numpy.loadtxt("../data/data_1st_layer.txt")

  n_2D = data_1st[:, 0]
  delta = data_1st[:, 2]
  d = data_1st[:, 1]
  y = n_2D*(delta - delta[9])*d
  b = 10**17 * const.e * const.e / (10**-9)**3 * 10**-9 * 3.2e-10 / (2*20*const.epsilon_0)
  y = y*b*1000


  plt.figure(figsize=(3.5, 3))
  plt.plot(data_MD[:, 0], data_MD[:, 2], "s-", label="MD Result")
  plt.plot(n_2D, y, "o--", label="Model")
  plt.xlabel(r"$\sigma_{\mathrm{2D}}$ ($10^{13}$ $e \cdot$cm$^{-2}$)")
  plt.ylabel(r"$\Delta \Phi_{\mathrm{Coul}}$ (mJ$\cdot$m$^{-2}$)")
  plt.legend(loc=0)
  plt.savefig("../img/SI_compare_model.pdf")
#+END_SRC

#+ATTR_LATEX: :width 0.95\linewidth
#+NAME: fig-SI-mode
#+CAPTION: Simple model for the asymmetric behavior of $\Delta \Phi_{\mathrm{Coul}}$ as a function of $\sigma_{\mathrm{2D}}$. (a) Proposed orientation of first layer water molecules on n- and p-doped graphene surface. (b) Comparison between the $\Delta \Phi_{\mathrm{Coul}}$ values calculated by MD simulation and the proposed model. The results obtained by the simple capacitance model shows similar shift of $\Delta \Phi_{\mathrm{2D}}$ maximum.
[[file:../img/SI_model.pdf]]




[[bibliography:ref.bib]]
